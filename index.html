<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitAlura</title>
</head>
<body>
    
    <ul>
        <h1>Comandos de Git Bash, como crear nuestro Repositorio</h1>
        <li>Permite almacenamiento y acceso a un historial de cambios.</li>
        <li>Nos deja organizar el trabajo en equipo, manteniendo los cambios en los archivos en un servidor específico para eso</li>
        <li>clikeando en el titulo del git bash se puede acceder a una configuracion/opciones/select/..ejemplo cambiar tamaño de letras</li>
        <li>COMANDOS:</li>
        <li>git --version (para ver la version)</li>
        <li>dir (para ver todos los documentos y carpetas)</li>
        <li>cd (para cambiar de carpeta)</li>
        <li>ls (es parecido al dir, se ven todos los archivos)</li>
        <li>git init (para inicializar el repo, solo se re aliza una vez)</li>
        <li>Martin Maldonado@DESKTOP-VMK0ASK MINGW64 ~/Desktop/gitAlura (master)</li>
        <li>Se agrega a la branch master</li>
        <li>git status (para saber los cambios realizados y estados en el que estan los archivos)</li>
        <li>Cada cambio que realices se registra en un historial y se puede ver y restaurar en cualquier momento</li>
        <li>git add . (para monitorear los archivos que no fueron agregados aun)</li>
        <li>el git add nombreArchivo o git add . (agrega todos los archivos)</li>
        <li>Git administra repositorios y cada persona del equipo puede tener su propio repositorio.</li>
        <li>¿Cómo hacemos que Git vea una carpeta en particular como un repositorio y observe los cambios en sus archivos?</li>
        <li>git init inicializa un repositorio en el directorio donde se ejecuta el comando. Desde este comando, Git podrá administrar los cambios realizados en los archivos.</li>
        <li>Git no ayuda a:</li>
        <li>a mantener un historial de cambios</li>
        <li>a tener control sobre cada cambio en el código</li>
        <li>a que un cambio de una persona no influya en el cambio realizado por otra</li>
    </ul>

    
    <ul>
        <h1>Como guardar|monitorear|trakear los cambios / más comandos</h1>
        <li>git add .</li>
        <li>git status (ahora deberia de aparecer en verde nuestro archivo y no color rojo, lo que significa que fue agregado correctamente )</li>
        <li>git rm --cached index.html (en el caso que ese archivo querramos dejar de monitorear)
        </li>
        <li>git commit -m "se creo index.html con lista de comandos git" (para guardar esa modificacion en el repo de git)</li>
        <li>ahi lo comitiamos, detras del -m escribimos el mensaje entre comillas, que describa en lo que trabajamos</li>
        <li>[master (root-commit) a6eb123] (dentro del mensaje que nos arroja git lo importante es el numero, que va a permitir viajar en el tiempo en el caso que nosotros querramos volver a este punto preciso de nuestro codigo)</li>
        <li>en caso contrario es que deberan realizar la configuracion de usuario, datos precisos con los que se registraron a git</li>
        <li>git config --global user.email "suCorreoelectronico@gmail.com"</li>
        <li>git config --global user.name "suNombre"</li>
        <li>git status</li>
        <li>git add . (agregamos todas las modificaciones nuevamente)</li>
        <li>aquí hay algunas definiciones interesantes:</li>
        <li>HEAD: Estado actual de nuestro código, es decir, donde nos colocó Git</li>
        <li>Working tree: Lugar donde los archivos realmente están siendo almacenados</li>
        <li>index: Lugar donde Git almacena lo que será commiteado, es decir, la ubicación entre el working tree y el repositorio de Git en sí.</li>
    </ul>

    <ul>
        <h1>Viendo el historico</h1>
        <li>git log (este comando muestra el historial de commit)</li>
        <li>commit a6eb1234482c6ad9afbbd9c4764112535d6342ba (el commit hash nos debe mostrar)</li>
        <li>git config user.name (para consultar nombre de usuario registrado)</li>
        <li>git config user.email (para consultar email registrado)</li>
        <li>Recordemos que se puede itilizar tanto la configuracion local que va a ser solo para este repo, ej..git config --local user.name "nombre" | o de forma global.. ej.. git config --global user.name "nombre".. aplica lo mismo para el email </li>
        <li>clear (comando para limpiar la pantalla)</li>
        <li>git log --oneline (otro comando para visualizar los commits en una sola linea)</li>
        <li>git log -p (para ver los archivos modificados en los commits)</li>
        <li>:q (para salir de ese editor de commits)</li>
        <li>git log --pretty="format:%H" (para ver solo los hash de cada commit unicamente)</li>
        <li>¿Cómo podemos definir el nombre de la persona que ejecuta commits en el repositorio local actual?</li>
        <li>git config --local user.name "Nombre de la persona"</li>
        <li>Esto se realiza cuando tranajamos en equipo con un repo de una empresa por ejemplo</li>
        <li>Así todos los commits ejecutados en este repositorio serán atribuidos a la persona con el nombre Nombre de la persona. Para más detalles y otras configuraciones posibles (incluso algunas más avanzadas), pueden visitar este link: https://git-scm.com/book/en/v2Customizing-Git-Git-Configuration.</li>
        <li>hoja de trucos: https://devhints.io/git-log</li>
        
    </ul>
   
         
    <ul>
        <h1>.gitignore (Archivos que queremos que Git ignore y no se vean en el
        repositorio virtual NI SEA MONITOREADO POR GIT)</h1>
        <li>tenemos que crear el archivo .gitignore</li>
        <li>y a modo de ejemplo excluimos:</li>
        <li>carpeta/</li>
        <li>a.config</li>
        <li>luego en el comando git bash:</li>
        <li>git add .gitignore  (luego del .git con tabulador nos autocompleta.gitignore)</li>
        <li>luego comitiamos</li>
        <li>git commit -m " commit n°3 agregamos archivos al index, tambienagregamos .gitignore"</li> 
        <li>git add .</li>
        <li>git commit -m " commit n°4 agregamos archivos al index"</li>
        <li>git log --oneline (apreciamos los 4 commits)</li>
        <li>EN CADA ALTERACION SIGNIFICATIVA SE DEBE AGREGAR UN COMMIT, LAS BUENAS PRACTICAS NOS RECOMIENDAN JAMAS COMITIAR UN CODIGO QUE NO FUNCIONA</li>
    </ul>

    <ul>
        <h1>Compartiendo el trabajo en repositorio remoto</h1>
        <li>cd.. (vuelve una carpeta antes)</li>
        <li>mkdir nombreCarpeta (crea una carpeta nueva desde el bash)</li>
        <li>cd servidorGit/</li>
        <li>git init --bare  (indica que ese repositorio es puro, solo contiene las modificaciones de los archivos)</li>
        <li>ahora tenemos el camino de nuestro repo remoto</li>
        <li>C:/Users/Martin Maldonado/Desktop/gitAlura/servidorGit/</li>
        <li>Martin Maldonado@DESKTOP-VMK0ASK MINGW64 ~/Desktop/gitAlura/servidorGit (BARE:master)</li>
        <li>cd .. (volvemos a nuestra carpeta anterior)</li>
        <li>git remote (lista todos los servidores remotos que tiene el proyecto)</li>
        <li>Creamos un repo remoto local en git</li>
        <li>git remote add origin C:/Users/Martin Maldonado/Desktop/gitAlura/servidorGit/</li>
        <li>git remote -v (para ver los servidores en donde alojamos la info)</li>
        <li>cd ..</li>
        <li>mkdir otrousuarioquetrabajeenelproyecto</li>
        <li>cd otrousuarioquetrabajeenelproyecto/</li>
        <li>git clone C:/Users/Martin Maldonado/Desktop/gitAlura/servidorGit/ proyecto (creara una carpeta proyecto con la info)</li>
        <li>cd ../.. (paras salir de esa carpeta y volver a la principal)</li>
        <li>suponiendo que trabajara en el proyecto previo lo clona</li>
        <li>En el último video trabajamos bastante. Nuestra primera tarea fue crear un nuevo repositorio, que será utilizado como nuestro “servidor” de Git, o sea, todos los miembros del equipo accederán a él para compartir
        sus cambios.
        ¿Cómo hicimos para definir un repositorio Git en este caso?</li>
        <li>git init --bare</li>
        <li>Con este comando creamos un repositorio que no tendrá la working tree, o sea, no contendrá una copia de nuestros archivos. Como el repositorio servirá solo como servid para que otros miembros del equipo sincronicen sus trabajos, disminuimos espacio de almacenamiento esta forma.</li>
        <li>Antes de sincronizar nuestros cambios en el código con algún repositorio remoto, necesitamos agregarlos a nuestro repositorio local.
        ¿Cómo agregamos este enlace entre los repositorios?</li>
        <li>git remote add nombre-repositorio camino/del/repositorio</li>
        <li>De esta forma tendremos un link de nuestro repositorio local con el repositorio remoto, que llamamos de nombre-repositorio, que está almacenado en camino/del/repositorio.</li>
    </ul>

    <ul>
        <h1>Sincronizando datos</h1>
        <li>cd otrousuarioquetrabajeenelproyecto/proyecto/</li>
        <li>ls</li>
        <li>git remote (origin por defecto)</li>
        <li>git remote rename local servidorlocal</li>
        <li>git remote (no debe aparecer servidorlocal)</li>
        <li>git pull servidorlocal master</li>
        <li>creara una nueva rama para ese usuario</li>
        <li>ls (le deberia figurar el index.html)</li>
        <li>leugo de que el usuario agregue y comitee las modificaciones</li>
        <li>git push servidorlocal master  (lo pushea para ue aplique los cambios)</li>
        <li>cd ../..</li>
        <li>ls</li>
        <li>cd nombrecarpeta (para movernos entre carpetas)</li>
        <li>git pull servidorlocal master</li>
        <li>git log -p (vemos que modico el otro usuario)</li>
        <li>:q  (salimos de ese espacio)</li>
        <li>Además de agregar repositorios remotos para sincronizar los datos, vimos que git clone trae un repositorio remoto para nuestra computadora, creando un repositorio local.</li>
        <li>Al modificar el código en nuestro repositorio local, ¿cómo enviamos las modificaciones para el repositorio remoto?</li>
        <li>git push [repositorio] master</li>
        <li>De esta forma enviamos las modificaciones de nuestra Branch master (hablaremos más sobre branches dentro de poco) hacia el repositorio remoto. Basta con substituir [repositor por el nombre que dimos al repositorio al agregarlo. Ahora, para traer los datos que están en el reposito remoto, podemos utilizar git pull [repositorio] master.</li>
    </ul>

    <ul>
        <h1>GitHub</h1>
        <li>git remote add origin https://github.com/M-1985-web/servidorGitAluraComandos.git</li>
        <li>git push -u origin master (subimos todo el proyecto remotamente, siempre comitiar antes de subir cambios)
        </li>
        <li>Con GitHub, podemos tener repositorios remotos públicos y privados gratuitos para almacenar y compartir el código de nuestros proyectos.</li>
    </ul>

    <ul>
        <h1>Trabajo en equipo BRANCHES</h1>
        <li>git branch (nos arrojara master o las ramas que tengamos)</li>
        <li>git branch rama1 (creamos una nueva rama)</li>
        <li>git checkout rama1 (cambiamos a la rama que creamos)</li>
        <li>modifiquemos algo a modo de ejemplo</li>
        <li>git add .</li>
        <li>comitiamos en esa rama</li>
        <li>git checkout master (si pasamos a la rama master no veremos todo el trabajo relaizado en rama1)</li>
        <li>git checkout rama1 (volvemos a la rama1)</li>
        <li>git checkout -b lista (creamos una rama y nos redirecciona directo a esa rama)</li>
        <li>Es interesante separar el desarrollo de funcionalidades en diferentes branches, para que los cambios en el código de una no influyan en el funcionamiento de otra.</li>
        <h1>Uniendo el trabajo</h1>
        <li>git merge rama1 (aca uno las dos ramas)</li>
        <li>:x (para salir si nos posiciona en el editor)</li>
        <li>¿Cómo podemos hacer el merge de la Branch titulo hacia la Branch master?</li>
        <li>git checkout master y git merge titulo</li>
        <li>De esta forma colocaremos el HEAD en la Branch master, o sea, haremos que nuestro código esté en el estado que lo dejamos con el últimocommit en master. Después, uniremos trabajo de la Branch titulo con la Branch actual (master).</li>
        <li>git log --graph (para ver todo el camino de los commit)</li>
        <li>git checkout rama1</li>
        <li>mpdificamos algo a modo de ejemplo</li>
        <li>git checkout master (volvemos master pero esta ves utilizamos el rebase)</li>
        <li>git rebase rama1 (aca unificamos los commits)</li>
        <li>control c en caso de que nos confundamos en el comando</li>
        <li>El merge junta los trabajos y genera un merge commit. El rebase aplica los commits de otra Branch en la Branch actual.</li>
        <li>git pull -u origin master (para actualizar los archivos en la branch actual)</li>
        <li>git push -u origin master</li>
    </ul>

    <ul>
        <h1>Deshaciendo trabajo</h1>
        <li>git restore index.html (seleccionamos el nombre del archivo en el cual queremos deshacer los cambios)</li>
        <li>ahora si a ese cambio le hice git add .</li>
        <li>antes de comitiarlo podemos utilizar:</li>
        <li>git restore --staged index.html (vuelve a la instancia previa de hacer el git add .)</li>
        <li>en el peor de los casos si ya lo comitiamos</li>
        <li>y queremos deshacer ese cambio</li>
        <li>git log</li>
        <li>copiamos el hash de ese commit son unos 40 caracteres alfanumericos aproximadamente</li>
        <li>git revert masElNumeroDelHash</li>
        <li>crea un nuevo commit Deshaciendo el commit anterior</li>
        <li>:X   (para salir de la pantalla commitiada, si queremos podemos modificar el mensaje)</li>
        <li>¿Cuáles comandos, respectivamente, deshacen modificaciones antes de agregarlas (1), después de agregarlas, pero antes de commitearlas (2), y después de realizar el commit (3)?</li>
        <li>1 - git restor, 2 - git restore --stage, 3 - git revert</li>
        <li>Con el git restore deshacemos una modificación que aún no fue agregada al index o stage, o sea, antes de hacer git add. Después de agregar con git add, para deshacer  modificación, necesitamos sacarlo de este estado, con git restore --staged. Ahora, si ya hicimos el commit, comando git revert puede salvarnos</li>
    </ul>

    <ul>
        <h1>Guardando para despues</h1>
        <li>la guadamos en un lugar temporal pero no es como un commit</li>
        <li>git stash (nos da un hash)</li>
        <li>Primera opcion para recuperar el trabajo</li>
        <li>git stash list (nos lista los trabajos que guardamos)</li>
        <li>git stash apply 0 (los lista como un arrays, el primero es cero.pero luego debemos de eliminarla del stash)</li>
        <li>segunda opcion</li>
        <li>git stash pop (esta opcion es la mejor porque la agrega al trabajoy la elimina del stash)</li>
        <li>Este ultimo genera un merge con las modifiaciones que ya teniamos<li>
        <li>¿En qué momento el stash es útil?</li>
        <li>Cuando necesitamos parar en el medio del desarrollo de algo, para poder hacer otra cosa.</li>
        <li>Cuando necesitamos pausar el desarrollo de alguna funcionalidad, o corrección, antes de finalizar, y tal vez no sea interesante realizar un commit, pues nuestro código puede estar funcionando aún. En este caso es interesante guardar el trabajo para poder volver a él después.</li>
    </ul>

    <ul>
        <h1>Viajando en el tiempo</h1>
        <li>git log --oneline  (para ver todos los commits)</li>
        <li>git checkout masElNumeroDeHash (el hash que nos arrojo el log, seleccionamos el momento exacto en el tiempo al cual queremos volver)</li>
        <li>git checkout -b (tenemos que crear una nueva branch)</li>
        <li>git checkout master (para volver a la master)</li>
        <li>Resumidamente, ¿para qué sirve el comando git checkout?</li>
        <li>Para dejar nuestro código en un estado determinado.</li>
        <li>La descripción del comando git checkout --help, en una traducción libre es: “Actualizar los archivos en working tree para que queden en la versión especificada. [… Básicamente, podemos dejar nuestro código en el estado de últ commit de una branch, de un commit específico, o incluso tags (que veremos más adelante).</li>
        <li>Que Git puede ayudarnos a deshacer cambios que no vamos a utilizar;</li>
        <li>Que, para deshacer un cambio antes de agregarlo para commit(con git add), podemos usar el comando git restore mas el archivo;</li>
        <li>Que, para deshacer un cambio después de agregarlo paracommit, primero debemos ejecutar git restore --staged (archivos) y luego podemos deshacerlos con git restore (files);</li>
        <li>Que, para revertir los cambios realizados en un commit, el comando git revert puede ser la solución;</li>
        <li>Que el comando git revert genera un nuevo commit informando que los cambios fueron deshechos;</li>
        <li>Que, para guardar un trabajo y reanudarlo más tarde, podemos usar git stash;</li>
        <li>Que, para ver qué cambios hay en el stash, podemos usar el comando git stash list;</li>
        <li>Que, con el comando git stash apply <número>, podemos aplicar un cambio específico al stash;</li>
        <li>Que el comando git stash drop <número> elimina un elemento determinado del stash;</li>
        <li>Que el comando git stash pop aplica y elimina el último cambio que se agregó alstash;</li>
        <li>Que git checkout sirve para dejar la copia del código de muestra aplicación en el estado que queremos:</li>
        <li>git checkout (branch) deja el código en el estado de una branchcon el nombre (branch)</li>
        <li>git checkout (hash) deja el código en el estado de commit con el hash (hash)
        </li>
    </ul>

    <ul>
        <h1>Viendo las modificaciones</h1>
        <li>git log -p (vemos un detalle bastante importante de los commit)</li>
        <li>:q (para salir de ese visor)</li>
        <li>git log --oneline (para ver todos los commits)</li>
        <li>git diff numHash..numHash (n°..(hasta es con dos puntos)n°)</li>
        <li>git diff enter (para agregar)</li>
        <li>git add .</li>
        <li>git commit</li>
        <li>en el caso de querer volver a la instancia anterior</li>
        <li>git restore --staget index.html</li>
        <li>git status</li>
        <li>git restore index.html (el index es a modo de ejemplo ahi puede ir el archivo que querramos o agregar o modificar o lo que sea)</li>
        <li>así podemos comenzar a analizar con más control todas las modificaciones que fueron agregadas durante un desarrollo de un proyecto. Conseguimos tener un control más fino en ellos, ver las modificaciones entre commits, entre lo que estamos haciendo ahora y lo que ya  commiteado.</li>
        <li>Entonces con git diff podemos ver todas las modificaciones, pero después de haber visto todas la modificaciones y garantizado que no hay bugs, ¿cómo puedo generar una versión? Por ejemplo una release o la versión 0.1. ¿Cómo puedo informar esto para Git, clavar una bandera acá y decir: "ese commit de acá es la release 0.1"?</li>
        <li>Con el comando git diff, vimos que es posible visualizar las modificaciones realizadas en determinado código. Podemos ver las diferencias entre commits, branches</li>
        <li>¿Cómo exhibe git diff las modificaciones en el código?</li>
        <li>+ línea agregada,- línea eliminada,- línea modificada (versión antigua)
        ,+ línea modificada (nueva versión)</li>
        <li>El símbolo de sustracción (-) antes de la línea indica que ella no está más presente en el archivo. Ahora, el símbolo de adición (+) muestra que es una línea nueva. Las modificaciones son representadas por una
        eliminación y adición de línea.</li>
    </ul>
    
    <ul>
        <h1>Releases/Versiones</h1>
        <li>git log -n 2 (veo los ultimos dos commit)</li>
        <li>git tag -a v0.1.0 -m "lanzando la primer version (BETA)" (le puedo poner el nombre que quiera, ej: cocodrilo, puedo agregar un mensaje tambien/li>
        <li>git tag (no deberia arrojar v.0.1.0)</li>
        <li>git add .</li>
        <li>git commit -m "se agrego primera version de la app"</li>
        <li>git push -u origin master</li>
        <li>git push origin v0.1.0  (subo la version)</li>
        <li>Generamos un punto historico de la app</li>
        <li>Esto es muy bueno, es una feature muy importante, es una característica muy importante de GitHub para tener en cuenta.</li>
        <li>¿Qué resultado genera el envío de una tag para Github?</li>
        <li>Genera una Release, o sea, conseguiremos bajar un archivo compactado con nuestro código en este punto.</li>
        <li>Github nos da la posibilidad de bajar un archivo compactado que contiene el código en el estado en que el tag fue generado.</li>
        <li>Que es posible ver qué cambios se hicieron en cada archivo, con el comando git diff</li>
        <li>Que, al escribir sólo git diff, vemos los cambios en nuestros archivos que no se agregaron para commit (con git add)</li>
        <li>Que es posible comparar cambios entre dos ramas con git diff (branch1) .. (branch2)
        </li>
        <li>Que es posible comparar los cambios realizados entre un commit y otro, usando el comando git diff (commit1).. (commit2)
        </li>
        <li>Que Git nos permite guardar “marcos” de nuestra aplicación, por ejemplo, generando versiones, a través de git tag</li>
        <li>Que el comando git tag -a se usa para generar una nueva tag</li>
        <li>Las Releases de GitHub, que son generadas para cada tag de Git que creamos en nuestro repositorio</li>
    </ul>




    
    
    
</body>
</html>

